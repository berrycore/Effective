잘 작동하는 equals 메소드를 만드는 방법

1. 객체의 값을 비교할 필요 없고 참조만으로 같은 객체인지 비교 가능하면 == 연산자를 사용하자.

   - 그리고 같다면 true 를 반환한다. 코드 성능을 최적화 하는 것에 불과하지만,
     만일 비교하는 것 자체의 리소스가 많이 든다면 이렇게 할 가치가 있다.

2. instanceof 연산자를 사용해서 전달된 인자가 올바른 타입인지 확인하자.

   - 만일 그렇지 않다면 false 를 반환한다.

3. 인자 타입을 올바른 타입으로 변환 한다.

   - 이러한 casting 은 instanceof 검사 후에 행하게 되므로 예외가 생기지 않고 안전하게 처리된다.

4. 클래스의 중요한(꼭 비교해야 하는) 필드 각각에 대해서는 인자로 전달된 객체의 필드와
   현재 객체(equals 메소드가 호출된)의 필드가 모두 같은지 빠뜨리지 말고 비교한다.

   - 그리고 모두 같다면 true 를 반환하고 그렇지 않으면 false 를 반환한다.

5. equals 메소드를 작성한 후에는 과연 그 메소드가 대칭적이며, 이행적이고, 일관성이 있는지 확인한다
   Unit테스트코드를 작성하여 속성들이 지켜지는지를 검사한다. (재귀성과 null아님)도 만족해야 한다.

       // [ equals overriding 계약 조건 ]
       //
       // 1. 재귀적 (Reflexive)
       //     null 이 아닌 모든 참조값에 대해서 x.equals(x) 는 반드시 true 를 반환 해야 한다.
       //
       // 2. 대칭적 (Symmetric)
       //
       //     null 이 아닌 모든 참조값 x와 y에 대해 y.equals(x) 가 true 를 반환 한다면
       //                                        x.equals(y) 도 true 를 반환해야 한다.
       //
       // 3. 이행적 (Transitive)
       //     null 이 아닌 모든 참조값 x,y,z에 대해 만일 x.equals(y) 가 true 를 반환하고
       //                                             y.equals(z) 가 true 를 반환한다면
       //                                             x.equals(z) 도 반드시 true 를 반환해야 한다
       //
       // 4. 일관적 (Consistent)
       //     null 이 아닌 모든 참조값 x와 y에 대해, equals 메소드에서 객체 비교시 사용하는 정보가 변경되지 않는다면
       //     x.equals(y) 를 여려번 호출하더라도 일관성 있게 true 또는 false 를 반환해야 한다.
       //
       // 5. null 이 아닌 모든 참조값 x에 대해, x.equals(null) 은 반드시 false 를 반환해야 한다.

6. equals 메소드를 오버라이드 할 때는 hashCode 메소드도 항상 오버라이드 한다
7. equals 메소드의 매개변수 타입을 Object 대신 다른 타입으로 바꾸지 말라